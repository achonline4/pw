<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/abhishek/.cargo/registry/src/github.com-1ecc6299db9ec823/zerocopy-0.8.26/src/pointer/transmute.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>transmute.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../../normalize.css"><link rel="stylesheet" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../../ayu.css" disabled><link rel="stylesheet" href="../../../dark.css" disabled><link rel="stylesheet" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script defer src="../../../source-script.js"></script><script defer src="../../../source-files.js"></script><script defer src="../../../main.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../zerocopy/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../../zerocopy/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div></a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../zerocopy/index.html"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
</pre><pre class="rust"><code><span class="comment">// Copyright 2025 The Fuchsia Authors
//
// Licensed under a BSD-style license &lt;LICENSE-BSD&gt;, Apache License, Version 2.0
// &lt;LICENSE-APACHE or https://www.apache.org/licenses/LICENSE-2.0&gt;, or the MIT
// license &lt;LICENSE-MIT or https://opensource.org/licenses/MIT&gt;, at your option.
// This file may not be copied, modified, or distributed except according to
// those terms.

</span><span class="kw">use </span>core::{
    cell::{Cell, UnsafeCell},
    mem::{ManuallyDrop, MaybeUninit},
    num::Wrapping,
};

<span class="kw">use crate</span>::{
    pointer::{invariant::<span class="kw-2">*</span>, PtrInner},
    FromBytes, Immutable, IntoBytes, Unalign,
};

<span class="doccomment">/// Transmutations which are sound to attempt, conditional on validating the bit
/// validity of the destination type.
///
/// If a `Ptr` transmutation is `TryTransmuteFromPtr`, then it is sound to
/// perform that transmutation so long as some additional mechanism is used to
/// validate that the referent is bit-valid for the destination type. That
/// validation mechanism could be a type bound (such as `TransmuteFrom`) or a
/// runtime validity check.
///
/// # Safety
///
/// ## Post-conditions
///
/// Given `Dst: TryTransmuteFromPtr&lt;Src, A, SV, DV, _&gt;`, callers may assume the
/// following:
///
/// Given `src: Ptr&lt;&#39;a, Src, (A, _, SV)&gt;`, if the referent of `src` is
/// `DV`-valid for `Dst`, then it is sound to transmute `src` into `dst: Ptr&lt;&#39;a,
/// Dst, (A, Unaligned, DV)&gt;` by preserving pointer address and metadata.
///
/// ## Pre-conditions
///
/// Given `src: Ptr&lt;Src, (A, _, SV)&gt;` and `dst: Ptr&lt;Dst, (A, Unaligned, DV)&gt;`,
/// `Dst: TryTransmuteFromPtr&lt;Src, A, SV, DV, _&gt;` is sound if all of the
/// following hold:
/// - Forwards transmutation: Either of the following hold:
///   - So long as `dst` is active, no mutation of `dst`&#39;s referent is allowed
///     except via `dst` itself
///   - The set of `DV`-valid `Dst`s is a superset of the set of `SV`-valid
///     `Src`s
/// - Reverse transmutation: Either of the following hold:
///   - `dst` does not permit mutation of its referent
///   - The set of `DV`-valid `Dst`s is a subset of the set of `SV`-valid `Src`s
/// - No safe code, given access to `src` and `dst`, can cause undefined
///   behavior: Any of the following hold:
///   - `A` is `Exclusive`
///   - `Src: Immutable` and `Dst: Immutable`
///   - It is sound for shared code to operate on a `&amp;Src` and `&amp;Dst` which
///     reference the same byte range at the same time
///
/// ## Proof
///
/// Given:
/// - `src: Ptr&lt;&#39;a, Src, (A, _, SV)&gt;`
/// - `src`&#39;s referent is `DV`-valid for `Dst`
/// - `Dst: SizeEq&lt;Src&gt;`
///
/// We are trying to prove that it is sound to perform a pointer address- and
/// metadata-preserving transmute from `src` to a `dst: Ptr&lt;&#39;a, Dst, (A,
/// Unaligned, DV)&gt;`. We need to prove that such a transmute does not violate
/// any of `src`&#39;s invariants, and that it satisfies all invariants of the
/// destination `Ptr` type.
///
/// First, all of `src`&#39;s `PtrInner` invariants are upheld. `src`&#39;s address and
/// metadata are unchanged, so:
/// - If its referent is not zero sized, then it still has valid provenance for
///   its referent, which is still entirely contained in some Rust allocation,
///   `A`
/// - If its referent is not zero sized, `A` is guaranteed to live for at least
///   `&#39;a`
///
/// Since `Dst: SizeEq&lt;Src&gt;`, and since `dst` has the same address and metadata
/// as `src`, `dst` addresses the same byte range as `src`. `dst` also has the
/// same lifetime as `src`. Therefore, all of the `PtrInner` invariants
/// mentioned above also hold for `dst`.
///
/// Second, since `src`&#39;s address is unchanged, it still satisfies its
/// alignment. Since `dst`&#39;s alignment is `Unaligned`, it trivially satisfies
/// its alignment.
///
/// Third, aliasing is either `Exclusive` or `Shared`:
/// - If it is `Exclusive`, then both `src` and `dst` satisfy `Exclusive`
///   aliasing trivially: since `src` and `dst` have the same lifetime, `src` is
///   inaccessible so long as `dst` is alive, and no other live `Ptr`s or
///   references may reference the same referent.
/// - If it is `Shared`, then either:
///   - `Src: Immutable` and `Dst: Immutable`, and so `UnsafeCell`s trivially
///     cover the same byte ranges in both types.
///   - It is explicitly sound for safe code to operate on a `&amp;Src` and a `&amp;Dst`
///     pointing to the same byte range at the same time.
///
/// Fourth, `src`&#39;s validity is satisfied. By invariant, `src`&#39;s referent began
/// as an `SV`-valid `Src`. It is guaranteed to remain so, as either of the
/// following hold:
/// - `dst` does not permit mutation of its referent.
/// - The set of `DV`-valid `Dst`s is a superset of the set of `SV`-valid
///   `Src`s. Thus, any value written via `dst` is guaranteed to be `SV`-valid
///   for `Src`.
///
/// Fifth, `dst`&#39;s validity is satisfied. It is a given of this proof that the
/// referent is `DV`-valid for `Dst`. It is guaranteed to remain so, as either
/// of the following hold:
/// - So long as `dst` is active, no mutation of the referent is allowed except
///   via `dst` itself.
/// - The set of `DV`-valid `Dst`s is a superset of the set of `SV`-valid
///   `Src`s. Thus, any value written via `src` is guaranteed to be a `DV`-valid
///   `Dst`.
</span><span class="kw">pub unsafe trait </span>TryTransmuteFromPtr&lt;Src: <span class="question-mark">?</span>Sized, A: Aliasing, SV: Validity, DV: Validity, R&gt;:
    SizeEq&lt;Src&gt;
{
}

<span class="attribute">#[allow(missing_copy_implementations, missing_debug_implementations)]
</span><span class="kw">pub enum </span>BecauseMutationCompatible {}

<span class="comment">// SAFETY:
// - Forwards transmutation: By `Dst: MutationCompatible&lt;Src, A, SV, DV, _&gt;`, we
//   know that at least one of the following holds:
//   - So long as `dst: Ptr&lt;Dst&gt;` is active, no mutation of its referent is
//     allowed except via `dst` itself if either of the following hold:
//     - Aliasing is `Exclusive`, in which case, so long as the `Dst` `Ptr`
//       exists, no mutation is permitted except via that `Ptr`
//     - Aliasing is `Shared`, `Src: Immutable`, and `Dst: Immutable`, in which
//       case no mutation is possible via either `Ptr`
//   - `Dst: TransmuteFrom&lt;Src, SV, DV&gt;`. Since `Dst: SizeEq&lt;Src&gt;`, this bound
//     guarantees that the set of `DV`-valid `Dst`s is a supserset of the set of
//     `SV`-valid `Src`s.
// - Reverse transmutation: `Src: TransmuteFrom&lt;Dst, DV, SV&gt;`. Since `Dst:
//   SizeEq&lt;Src&gt;`, this guarantees that the set of `DV`-valid `Dst`s is a subset
//   of the set of `SV`-valid `Src`s.
// - No safe code, given access to `src` and `dst`, can cause undefined
//   behavior: By `Dst: MutationCompatible&lt;Src, A, SV, DV, _&gt;`, at least one of
//   the following holds:
//   - `A` is `Exclusive`
//   - `Src: Immutable` and `Dst: Immutable`
//   - `Dst: InvariantsEq&lt;Src&gt;`, which guarantees that `Src` and `Dst` have the
//     same invariants, and have `UnsafeCell`s covering the same byte ranges
</span><span class="kw">unsafe impl</span>&lt;Src, Dst, SV, DV, A, R&gt;
    TryTransmuteFromPtr&lt;Src, A, SV, DV, (BecauseMutationCompatible, R)&gt; <span class="kw">for </span>Dst
<span class="kw">where
    </span>A: Aliasing,
    SV: Validity,
    DV: Validity,
    Src: TransmuteFrom&lt;Dst, DV, SV&gt; + <span class="question-mark">?</span>Sized,
    Dst: MutationCompatible&lt;Src, A, SV, DV, R&gt; + SizeEq&lt;Src&gt; + <span class="question-mark">?</span>Sized,
{
}

<span class="comment">// SAFETY:
// - Forwards transmutation: Since aliasing is `Shared` and `Src: Immutable`,
//   `src` does not permit mutation of its referent.
// - Reverse transmutation: Since aliasing is `Shared` and `Dst: Immutable`,
//   `dst` does not permit mutation of its referent.
// - No safe code, given access to `src` and `dst`, can cause undefined
//   behavior: `Src: Immutable` and `Dst: Immutable`
</span><span class="kw">unsafe impl</span>&lt;Src, Dst, SV, DV&gt; TryTransmuteFromPtr&lt;Src, Shared, SV, DV, BecauseImmutable&gt; <span class="kw">for </span>Dst
<span class="kw">where
    </span>SV: Validity,
    DV: Validity,
    Src: Immutable + <span class="question-mark">?</span>Sized,
    Dst: Immutable + SizeEq&lt;Src&gt; + <span class="question-mark">?</span>Sized,
{
}

<span class="doccomment">/// Denotes that `src: Ptr&lt;Src, (A, _, SV)&gt;` and `dst: Ptr&lt;Self, (A, _, DV)&gt;`,
/// referencing the same referent at the same time, cannot be used by safe code
/// to break library safety invariants of `Src` or `Self`.
///
/// # Safety
///
/// At least one of the following must hold:
/// - `Src: Read&lt;A, _&gt;` and `Self: Read&lt;A, _&gt;`
/// - `Self: InvariantsEq&lt;Src&gt;`, and, for some `V`:
///   - `Dst: TransmuteFrom&lt;Src, V, V&gt;`
///   - `Src: TransmuteFrom&lt;Dst, V, V&gt;`
</span><span class="kw">pub unsafe trait </span>MutationCompatible&lt;Src: <span class="question-mark">?</span>Sized, A: Aliasing, SV, DV, R&gt; {}

<span class="attribute">#[allow(missing_copy_implementations, missing_debug_implementations)]
</span><span class="kw">pub enum </span>BecauseRead {}

<span class="comment">// SAFETY: `Src: Read&lt;A, _&gt;` and `Dst: Read&lt;A, _&gt;`.
</span><span class="kw">unsafe impl</span>&lt;Src: <span class="question-mark">?</span>Sized, Dst: <span class="question-mark">?</span>Sized, A: Aliasing, SV: Validity, DV: Validity, R, S&gt;
    MutationCompatible&lt;Src, A, SV, DV, (BecauseRead, (R, S))&gt; <span class="kw">for </span>Dst
<span class="kw">where
    </span>Src: Read&lt;A, R&gt;,
    Dst: Read&lt;A, S&gt;,
{
}

<span class="doccomment">/// Denotes that two types have the same invariants.
///
/// # Safety
///
/// It is sound for safe code to operate on a `&amp;T` and a `&amp;Self` pointing to the
/// same referent at the same time - no such safe code can cause undefined
/// behavior.
</span><span class="kw">pub unsafe trait </span>InvariantsEq&lt;T: <span class="question-mark">?</span>Sized&gt; {}

<span class="comment">// SAFETY: Trivially sound to have multiple `&amp;T` pointing to the same referent.
</span><span class="kw">unsafe impl</span>&lt;T: <span class="question-mark">?</span>Sized&gt; InvariantsEq&lt;T&gt; <span class="kw">for </span>T {}

<span class="comment">// SAFETY: `Dst: InvariantsEq&lt;Src&gt; + TransmuteFrom&lt;Src, SV, DV&gt;`, and `Src:
// TransmuteFrom&lt;Dst, DV, SV&gt;`.
</span><span class="kw">unsafe impl</span>&lt;Src: <span class="question-mark">?</span>Sized, Dst: <span class="question-mark">?</span>Sized, A: Aliasing, SV: Validity, DV: Validity&gt;
    MutationCompatible&lt;Src, A, SV, DV, BecauseInvariantsEq&gt; <span class="kw">for </span>Dst
<span class="kw">where
    </span>Src: TransmuteFrom&lt;Dst, DV, SV&gt;,
    Dst: TransmuteFrom&lt;Src, SV, DV&gt; + InvariantsEq&lt;Src&gt;,
{
}

<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">enum </span>BecauseInvariantsEq {}

<span class="macro">macro_rules! </span>unsafe_impl_invariants_eq {
    (<span class="macro-nonterminal">$tyvar</span>:ident =&gt; <span class="macro-nonterminal">$t</span>:ty, <span class="macro-nonterminal">$u</span>:ty) =&gt; {{
        <span class="kw">crate</span>::util::macros::__unsafe();
        <span class="comment">// SAFETY: The caller promises that this is sound.
        </span><span class="kw">unsafe impl</span>&lt;<span class="macro-nonterminal">$tyvar</span>&gt; InvariantsEq&lt;<span class="macro-nonterminal">$t</span>&gt; <span class="kw">for </span><span class="macro-nonterminal">$u </span>{}
        <span class="comment">// SAFETY: The caller promises that this is sound.
        </span><span class="kw">unsafe impl</span>&lt;<span class="macro-nonterminal">$tyvar</span>&gt; InvariantsEq&lt;<span class="macro-nonterminal">$u</span>&gt; <span class="kw">for </span><span class="macro-nonterminal">$t </span>{}
    }};
}

<span class="macro">impl_transitive_transmute_from!</span>(T =&gt; MaybeUninit&lt;T&gt; =&gt; T =&gt; Wrapping&lt;T&gt;);
<span class="macro">impl_transitive_transmute_from!</span>(T =&gt; Wrapping&lt;T&gt; =&gt; T =&gt; MaybeUninit&lt;T&gt;);

<span class="comment">// SAFETY: `ManuallyDrop&lt;T&gt;` has the same size and bit validity as `T` [1], and
// implements `Deref&lt;Target = T&gt;` [2]. Thus, it is already possible for safe
// code to obtain a `&amp;T` and a `&amp;ManuallyDrop&lt;T&gt;` to the same referent at the
// same time.
//
// [1] Per https://doc.rust-lang.org/1.81.0/std/mem/struct.ManuallyDrop.html:
//
//   `ManuallyDrop&lt;T&gt;` is guaranteed to have the same layout and bit
//   validity as `T`
//
// [2] https://doc.rust-lang.org/1.81.0/std/mem/struct.ManuallyDrop.html#impl-Deref-for-ManuallyDrop%3CT%3E
</span><span class="kw">unsafe impl</span>&lt;T: <span class="question-mark">?</span>Sized&gt; InvariantsEq&lt;T&gt; <span class="kw">for </span>ManuallyDrop&lt;T&gt; {}
<span class="comment">// SAFETY: See previous safety comment.
</span><span class="kw">unsafe impl</span>&lt;T: <span class="question-mark">?</span>Sized&gt; InvariantsEq&lt;ManuallyDrop&lt;T&gt;&gt; <span class="kw">for </span>T {}

<span class="doccomment">/// Transmutations which are always sound.
///
/// `TransmuteFromPtr` is a shorthand for [`TryTransmuteFromPtr`] and
/// [`TransmuteFrom`].
///
/// # Safety
///
/// `Dst: TransmuteFromPtr&lt;Src, A, SV, DV, _&gt;` is equivalent to `Dst:
/// TryTransmuteFromPtr&lt;Src, A, SV, DV, _&gt; + TransmuteFrom&lt;Src, SV, DV&gt;`.
</span><span class="kw">pub unsafe trait </span>TransmuteFromPtr&lt;Src: <span class="question-mark">?</span>Sized, A: Aliasing, SV: Validity, DV: Validity, R&gt;:
    TryTransmuteFromPtr&lt;Src, A, SV, DV, R&gt; + TransmuteFrom&lt;Src, SV, DV&gt;
{
}

<span class="comment">// SAFETY: The `where` bounds are equivalent to the safety invariant on
// `TransmuteFromPtr`.
</span><span class="kw">unsafe impl</span>&lt;Src: <span class="question-mark">?</span>Sized, Dst: <span class="question-mark">?</span>Sized, A: Aliasing, SV: Validity, DV: Validity, R&gt;
    TransmuteFromPtr&lt;Src, A, SV, DV, R&gt; <span class="kw">for </span>Dst
<span class="kw">where
    </span>Dst: TransmuteFrom&lt;Src, SV, DV&gt; + TryTransmuteFromPtr&lt;Src, A, SV, DV, R&gt;,
{
}

<span class="doccomment">/// Denotes that any `SV`-valid `Src` may soundly be transmuted into a
/// `DV`-valid `Self`.
///
/// # Safety
///
/// Given `src: Ptr&lt;Src, (_, _, SV)&gt;` and `dst: Ptr&lt;Dst, (_, _, DV)&gt;`, if the
/// referents of `src` and `dst` are the same size, then the set of bit patterns
/// allowed to appear in `src`&#39;s referent must be a subset of the set allowed to
/// appear in `dst`&#39;s referent.
///
/// If the referents are not the same size, then `Dst: TransmuteFrom&lt;Src, SV,
/// DV&gt;` conveys no safety guarantee.
</span><span class="kw">pub unsafe trait </span>TransmuteFrom&lt;Src: <span class="question-mark">?</span>Sized, SV, DV&gt; {}

<span class="doccomment">/// # Safety
///
/// `T` and `Self` must have the same vtable kind (`Sized`, slice DST, `dyn`,
/// etc) and have the same size. In particular:
/// - If `T: Sized` and `Self: Sized`, then their sizes must be equal
/// - If `T: ?Sized` and `Self: ?Sized`, then it must be the case that, given
///   any `t: PtrInner&lt;&#39;_, T&gt;`, `&lt;Self as SizeEq&lt;T&gt;&gt;::cast_from_raw(t)` produces
///   a pointer which addresses the same number of bytes as `t`. *Note that it
///   is **not** guaranteed that an `as` cast preserves referent size: it may be
///   the case that `cast_from_raw` modifies the pointer&#39;s metadata in order to
///   preserve referent size, which an `as` cast does not do.*
</span><span class="kw">pub unsafe trait </span>SizeEq&lt;T: <span class="question-mark">?</span>Sized&gt; {
    <span class="kw">fn </span>cast_from_raw(t: PtrInner&lt;<span class="lifetime">&#39;_</span>, T&gt;) -&gt; PtrInner&lt;<span class="lifetime">&#39;_</span>, <span class="self">Self</span>&gt;;
}

<span class="comment">// SAFETY: `T` trivially has the same size and vtable kind as `T`, and since
// pointer `*mut T -&gt; *mut T` pointer casts are no-ops, this cast trivially
// preserves referent size (when `T: ?Sized`).
</span><span class="kw">unsafe impl</span>&lt;T: <span class="question-mark">?</span>Sized&gt; SizeEq&lt;T&gt; <span class="kw">for </span>T {
    <span class="attribute">#[inline(always)]
    </span><span class="kw">fn </span>cast_from_raw(t: PtrInner&lt;<span class="lifetime">&#39;_</span>, T&gt;) -&gt; PtrInner&lt;<span class="lifetime">&#39;_</span>, T&gt; {
        t
    }
}

<span class="comment">// SAFETY: Since `Src: IntoBytes`, the set of valid `Src`&#39;s is the set of
// initialized bit patterns, which is exactly the set allowed in the referent of
// any `Initialized` `Ptr`.
</span><span class="kw">unsafe impl</span>&lt;Src, Dst&gt; TransmuteFrom&lt;Src, Valid, Initialized&gt; <span class="kw">for </span>Dst
<span class="kw">where
    </span>Src: IntoBytes + <span class="question-mark">?</span>Sized,
    Dst: <span class="question-mark">?</span>Sized,
{
}

<span class="comment">// SAFETY: Since `Dst: FromBytes`, any initialized bit pattern may appear in the
// referent of a `Ptr&lt;Dst, (_, _, Valid)&gt;`. This is exactly equal to the set of
// bit patterns which may appear in the referent of any `Initialized` `Ptr`.
</span><span class="kw">unsafe impl</span>&lt;Src, Dst&gt; TransmuteFrom&lt;Src, Initialized, Valid&gt; <span class="kw">for </span>Dst
<span class="kw">where
    </span>Src: <span class="question-mark">?</span>Sized,
    Dst: FromBytes + <span class="question-mark">?</span>Sized,
{
}

<span class="comment">// FIXME(#2354): This seems like a smell - the soundness of this bound has
// nothing to do with `Src` or `Dst` - we&#39;re basically just saying `[u8; N]` is
// transmutable into `[u8; N]`.

// SAFETY: The set of allowed bit patterns in the referent of any `Initialized`
// `Ptr` is the same regardless of referent type.
</span><span class="kw">unsafe impl</span>&lt;Src, Dst&gt; TransmuteFrom&lt;Src, Initialized, Initialized&gt; <span class="kw">for </span>Dst
<span class="kw">where
    </span>Src: <span class="question-mark">?</span>Sized,
    Dst: <span class="question-mark">?</span>Sized,
{
}

<span class="comment">// FIXME(#2354): This seems like a smell - the soundness of this bound has
// nothing to do with `Dst` - we&#39;re basically just saying that any type is
// transmutable into `MaybeUninit&lt;[u8; N]&gt;`.

// SAFETY: A `Dst` with validity `Uninit` permits any byte sequence, and
// therefore can be transmuted from any value.
</span><span class="kw">unsafe impl</span>&lt;Src, Dst, V&gt; TransmuteFrom&lt;Src, V, Uninit&gt; <span class="kw">for </span>Dst
<span class="kw">where
    </span>Src: <span class="question-mark">?</span>Sized,
    Dst: <span class="question-mark">?</span>Sized,
    V: Validity,
{
}

<span class="comment">// SAFETY:
// - `ManuallyDrop&lt;T&gt;` has the same size as `T` [1]
// - `ManuallyDrop&lt;T&gt;` has the same validity as `T` [1]
//
// [1] Per https://doc.rust-lang.org/1.81.0/std/mem/struct.ManuallyDrop.html:
//
//   `ManuallyDrop&lt;T&gt;` is guaranteed to have the same layout and bit validity as
//   `T`
</span><span class="kw">const _</span>: () = <span class="kw">unsafe </span>{ <span class="macro">unsafe_impl_for_transparent_wrapper!</span>(T: <span class="question-mark">?</span>Sized =&gt; ManuallyDrop&lt;T&gt;) };

<span class="comment">// SAFETY:
// - `Unalign&lt;T&gt;` promises to have the same size as `T`.
// - `Unalign&lt;T&gt;` promises to have the same validity as `T`.
</span><span class="kw">const _</span>: () = <span class="kw">unsafe </span>{ <span class="macro">unsafe_impl_for_transparent_wrapper!</span>(T =&gt; Unalign&lt;T&gt;) };
<span class="comment">// SAFETY: `Unalign&lt;T&gt;` promises to have the same size and validity as `T`.
// Given `u: &amp;Unalign&lt;T&gt;`, it is already possible to obtain `let t =
// u.try_deref().unwrap()`. Because `Unalign&lt;T&gt;` has the same size as `T`, the
// returned `&amp;T` must point to the same referent as `u`, and thus it must be
// sound for these two references to exist at the same time since it&#39;s already
// possible for safe code to get into this state.
</span><span class="kw">const _</span>: () = <span class="kw">unsafe </span>{ <span class="macro">unsafe_impl_invariants_eq!</span>(T =&gt; T, Unalign&lt;T&gt;) };

<span class="comment">// SAFETY:
// - `Wrapping&lt;T&gt;` has the same size as `T` [1].
// - `Wrapping&lt;T&gt;` has only one field, which is `pub` [2]. We are also
//   guaranteed per that `Wrapping&lt;T&gt;` has the same layout as `T` [1]. The only
//   way for both of these to be true simultaneously is for `Wrapping&lt;T&gt;` to
//   have the same bit validity as `T`. In particular, in order to change the
//   bit validity, one of the following would need to happen:
//   - `Wrapping` could change its `repr`, but this would violate the layout
//     guarantee.
//   - `Wrapping` could add or change its fields, but this would be a
//     stability-breaking change.
//
// [1] Per https://doc.rust-lang.org/1.85.0/core/num/struct.Wrapping.html#layout-1:
//
//   `Wrapping&lt;T&gt;` is guaranteed to have the same layout and ABI as `T`.
//
// [2] Definition from https://doc.rust-lang.org/1.85.0/core/num/struct.Wrapping.html:
//
//   ```
//   #[repr(transparent)]
//   pub struct Wrapping&lt;T&gt;(pub T);
//   ```
</span><span class="kw">const _</span>: () = <span class="kw">unsafe </span>{ <span class="macro">unsafe_impl_for_transparent_wrapper!</span>(T =&gt; Wrapping&lt;T&gt;) };

<span class="comment">// SAFETY: By the preceding safety proof, `Wrapping&lt;T&gt;` and `T` have the same
// layout and bit validity. Since a `Wrapping&lt;T&gt;`&#39;s `T` field is `pub`, given
// `w: &amp;Wrapping&lt;T&gt;`, it&#39;s possible to do `let t = &amp;w.t`, which means that it&#39;s
// already possible for safe code to obtain a `&amp;Wrapping&lt;T&gt;` and a `&amp;T` pointing
// to the same referent at the same time. Thus, this must be sound.
</span><span class="kw">const _</span>: () = <span class="kw">unsafe </span>{ <span class="macro">unsafe_impl_invariants_eq!</span>(T =&gt; T, Wrapping&lt;T&gt;) };

<span class="comment">// SAFETY:
// - `UnsafeCell&lt;T&gt;` has the same size as `T` [1].
// - Per [1], `UnsafeCell&lt;T&gt;` has the same bit validity as `T`. Technically the
//   term &quot;representation&quot; doesn&#39;t guarantee this, but the subsequent sentence
//   in the documentation makes it clear that this is the intention.
//
// [1] Per https://doc.rust-lang.org/1.81.0/core/cell/struct.UnsafeCell.html#memory-layout:
//
//   `UnsafeCell&lt;T&gt;` has the same in-memory representation as its inner type
//   `T`. A consequence of this guarantee is that it is possible to convert
//   between `T` and `UnsafeCell&lt;T&gt;`.
</span><span class="kw">const _</span>: () = <span class="kw">unsafe </span>{ <span class="macro">unsafe_impl_for_transparent_wrapper!</span>(T: <span class="question-mark">?</span>Sized =&gt; UnsafeCell&lt;T&gt;) };

<span class="comment">// SAFETY:
// - `Cell&lt;T&gt;` has the same size as `T` [1].
// - Per [1], `Cell&lt;T&gt;` has the same bit validity as `T`. Technically the term
//   &quot;representation&quot; doesn&#39;t guarantee this, but it does promise to have the
//   &quot;same memory layout and caveats as `UnsafeCell&lt;T&gt;`.&quot; The `UnsafeCell` docs
//   [2] make it clear that bit validity is the intention even if that phrase
//   isn&#39;t used.
//
// [1] Per https://doc.rust-lang.org/1.85.0/std/cell/struct.Cell.html#memory-layout:
//
//   `Cell&lt;T&gt;` has the same memory layout and caveats as `UnsafeCell&lt;T&gt;`. In
//   particular, this means that `Cell&lt;T&gt;` has the same in-memory representation
//   as its inner type `T`.
//
// [2] Per https://doc.rust-lang.org/1.81.0/core/cell/struct.UnsafeCell.html#memory-layout:
//
//   `UnsafeCell&lt;T&gt;` has the same in-memory representation as its inner type
//   `T`. A consequence of this guarantee is that it is possible to convert
//   between `T` and `UnsafeCell&lt;T&gt;`.
</span><span class="kw">const _</span>: () = <span class="kw">unsafe </span>{ <span class="macro">unsafe_impl_for_transparent_wrapper!</span>(T: <span class="question-mark">?</span>Sized =&gt; Cell&lt;T&gt;) };

<span class="macro">impl_transitive_transmute_from!</span>(T: <span class="question-mark">?</span>Sized =&gt; Cell&lt;T&gt; =&gt; T =&gt; UnsafeCell&lt;T&gt;);
<span class="macro">impl_transitive_transmute_from!</span>(T: <span class="question-mark">?</span>Sized =&gt; UnsafeCell&lt;T&gt; =&gt; T =&gt; Cell&lt;T&gt;);

<span class="comment">// SAFETY: `MaybeUninit&lt;T&gt;` has no validity requirements. Currently this is not
// explicitly guaranteed, but it&#39;s obvious from `MaybeUninit`&#39;s documentation
// that this is the intention:
// https://doc.rust-lang.org/1.85.0/core/mem/union.MaybeUninit.html
</span><span class="kw">unsafe impl</span>&lt;T&gt; TransmuteFrom&lt;T, Uninit, Valid&gt; <span class="kw">for </span>MaybeUninit&lt;T&gt; {}

<span class="comment">// SAFETY: `MaybeUninit&lt;T&gt;` has the same size as `T` [1].
//
// [1] Per https://doc.rust-lang.org/1.81.0/std/mem/union.MaybeUninit.html#layout-1:
//
//   `MaybeUninit&lt;T&gt;` is guaranteed to have the same size, alignment, and ABI as
//   `T`
</span><span class="kw">unsafe impl</span>&lt;T&gt; SizeEq&lt;T&gt; <span class="kw">for </span>MaybeUninit&lt;T&gt; {
    <span class="attribute">#[inline(always)]
    </span><span class="kw">fn </span>cast_from_raw(t: PtrInner&lt;<span class="lifetime">&#39;_</span>, T&gt;) -&gt; PtrInner&lt;<span class="lifetime">&#39;_</span>, MaybeUninit&lt;T&gt;&gt; {
        <span class="comment">// SAFETY: Per preceding safety comment, `MaybeUninit&lt;T&gt;` and `T` have
        // the same size, and so this cast preserves referent size.
        </span><span class="kw">unsafe </span>{ <span class="macro">cast!</span>(t) }
    }
}

<span class="comment">// SAFETY: See previous safety comment.
</span><span class="kw">unsafe impl</span>&lt;T&gt; SizeEq&lt;MaybeUninit&lt;T&gt;&gt; <span class="kw">for </span>T {
    <span class="attribute">#[inline(always)]
    </span><span class="kw">fn </span>cast_from_raw(t: PtrInner&lt;<span class="lifetime">&#39;_</span>, MaybeUninit&lt;T&gt;&gt;) -&gt; PtrInner&lt;<span class="lifetime">&#39;_</span>, T&gt; {
        <span class="comment">// SAFETY: Per preceding safety comment, `MaybeUninit&lt;T&gt;` and `T` have
        // the same size, and so this cast preserves referent size.
        </span><span class="kw">unsafe </span>{ <span class="macro">cast!</span>(t) }
    }
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="zerocopy" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.65.0 (897e37553 2022-11-02)" ></div></body></html>