window.SIDEBAR_ITEMS = {"macro":[["include_value","Includes a file and safely transmutes it to a value of an arbitrary type."],["transmute","Safely transmutes a value of one type to a value of another type of the same size."],["transmute_mut","Safely transmutes a mutable reference of one type to a mutable reference of another type of the same size and compatible alignment."],["transmute_ref","Safely transmutes a mutable or immutable reference of one type to an immutable reference of another type of the same size and compatible alignment."],["try_transmute","Conditionally transmutes a value of one type to a value of another type of the same size."],["try_transmute_mut","Conditionally transmutes a mutable reference of one type to a mutable reference of another type of the same size and compatible alignment."],["try_transmute_ref","Conditionally transmutes a mutable or immutable reference of one type to an immutable reference of another type of the same size and compatible alignment."]],"mod":[["byte_slice","Traits for types that encapsulate a `[u8]`."],["byteorder","Byte order-aware numeric primitives."],["error","Types related to error reporting."]],"struct":[["Ref","A typed reference derived from a byte slice."],["Split","A `T` that has been split into two possibly-overlapping parts."],["Unalign","A type with no alignment requirement."]],"trait":[["FromBytes","Types for which any bit pattern is valid."],["FromZeros","Types for which a sequence of `0` bytes is a valid instance."],["Immutable","Types which are free from interior mutability."],["IntoBytes","Types that can be converted to an immutable slice of initialized bytes."],["KnownLayout","Indicates that zerocopy can reason about certain aspects of a typeâ€™s layout."],["SplitAt","Types that can be split in two."],["TryFromBytes","Types for which some bit patterns are valid."],["Unaligned","Types with no alignment requirement."]]};