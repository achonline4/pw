# Rust

##### References - Books / Links

| S.No | Reference                                                                                                    | Remarks                                                                                                                                 |
| ---- | ------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------- |
| 1.   | Rust book abridged <br/>https://jasonwalton.ca/rust-book-abridged/https://jasonwalton.ca/rust-book-abridged/ | A condensed version of the original rust book - https://doc.rust-lang.org/stable/book/<br/><br/>Recommanded for experienced users only. |
|      |                                                                                                              |                                                                                                                                         |
|      |                                                                                                              |                                                                                                                                         |

##### Rust Dictionary

| S.No | Dictionary                                                                                 | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| ---- | ------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1.   | cargo new hello                                                                            | A command to create a new project (directory structure and hello world) called 'hello'.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| 2.   | cargo build                                                                                | A command to build / compile the project and produce executables. It creates a directory called **target** when run for the first time in a project. You can also use the **rustc** command to compile your source code, like **rustc main.rs**.                                                                                                                                                                                                                                                                                                                                |
| 3.   | cargo run                                                                                  | A command to run executable.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 4.   | cargo clean                                                                                | A command to clean all files generated by **cargo build** command. It deletes the **target** directory.                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| 5.   | Cargo.lock                                                                                 | File used to maintain list of dependencies and their versions used in a project.<br/>Its generated by the **cargo build** command.                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| 6.   | cargo check                                                                                | Command to verify that a project compiles without producing any executables.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 7.   | cargo build --release                                                                      | Command to produce release version of executables. By default cargo generates executables with debug information. Release executables are better optimized and don't have debug symbols or runtime safety checks.                                                                                                                                                                                                                                                                                                                                                               |
| 8.   | mut                                                                                        | A keyword which tells the compiler that the data can be modified. You can modify data either using the variable or a reference to that variable but in each case you need to tell the compiler explicitly about your intent of modifying it.<br/><br/>Eg:<br/>let mut guess;  // declare a modifiable variable named **guess**.<br/>read_line(&mut guess) // the same variable being passed to a function called **read_line** which is expected to modify the value using a reference to the variable.                                                                         |
| 9.   | the prelude                                                                                | Its a set of symbols Rust automatically brings into scope from the standard library which get used in almost every program.                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 10.  | &                                                                                          | A reference. For eg: a reference to a variable is passed by prepending & to it.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| 11.  | io::stdin()<br/>        .read_line(&mut guess)<br/>        .expect("Failed to read line"); | io - module that brings stdin symbol.<br/>read_line - function that reads a line from console.<br/>expect - error handling, in case read_line fails.                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 12.  | println!("")                                                                               | A macro that writes to standard output, its similar to printf in C.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| 13.  | cargo add <CRATE>                                                                          | Add a new crate to your project. It's like bringing in an external library.<br/>For eg: cargo add rand<br/>The above commands add the **rand**, which is a random number generator to the current project.                                                                                                                                                                                                                                                                                                                                                                      |
| 14.  | cargo update                                                                               | Update the lock file. Update all deps.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 15.  | use rand::Rng;<br/>rand::rng().random_range(1..=100);                                      | rand - crate or external lib<br/>rng - a trait or an interface.<br/>We called the random_range method from the rng trait.                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| 16.  | crate, trait, method                                                                       | crate - contains trait<br/>trait - contains method<br/>method - function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| 17.  | Integer types                                                                              | default - signed                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| 18.  | Shadowing                                                                                  | Its a concept in Rust where a scope can have 2 variable of different types but same name.<br/>It basically allows the following - <br/>1. Allow the variable to be modified without using **mut** <br/>2. Change the type of the variable. You can change String to u32 by shadowing.<br/>3. Basically allows a variable name to be used again instead of creating temp varible names to hold temp results. This is probably the better reason to have something like shadowing, IMO.                                                                                           |
| 19.  | Result                                                                                     | Its an ENUM with OK variant in case of success or ERR variant in case of failure. ENUMs in rust can carry extra information with them and not just a number.                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 20.  | cargo doc --open                                                                           | Generate HTML documentation for all the crates in your project and for your source code too.<br/>![](./readmeimages/c.png)                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| 21.  | cmp                                                                                        | A function in rust that takes a reference to a variable. It takes a reference and not value because of the following reasons -<br/>1. ownership - cmp does need to own the variable, it just needs to read it otherwise the variable becomes invalid after cmp has read it unless the ownership is returned to the caller.<br/>2. cmp can work on big types as well using references otherwise their values will need to be copied which is not a great idea.                                                                                                                   |
| 22.  | RUST_BACKTRACE=full cargo run                                                              | In case of an error in the program due to which it might panic, you can print the backtrace using this command.<br/>RUST_BACKTRACE=1/full<br/>![](readmeimages/d.png)                                                                                                                                                                                                                                                                                                                                                                                                           |
| 23.  | match                                                                                      | its like a switch statement in C, match a given input to a list of items.<br/>`let guess: u32 = match guess.trim().parse() {<br/>            Ok(num) => num,<br/>            Err(_) => continue,<br/>        };`                                                                                                                                                                                                                                                                                                                                                                |
| 24.  | const or constants                                                                         | Its used to declare constants but rust compiler warns if the constants are not declared in BLOCK letters.<br/>![](readmeimages/e.png)<br/>const CONSTVAR: u32 = 60 * 60 *3;<br/>Constants must always be annonated, Rust will not infer the type.<br/>const variables are stored in program binary and are hence immutable.<br/>Value of a const variable has to be something that can be evaluated at compile time.                                                                                                                                                            |
| 25.  | Variables                                                                                  | Variables cannot be declared at global scope unless they are static.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 26.  | Size needed at compile time                                                                | Rust requires that all static and const variable sizes be known at compile time so that it can allocate memory accordingly.<br/>This code fails to compile - <br/>`static HELLO_WORLD: str = "Hello, world!"`<br/>whereas this one doesn't - <br/>`static HELLO_WORLD: &str = "Hello, world!"`<br/>that's because Rust is a statically typed language. That means the size of the data type has to be known at compile time otherwise the compiler will throw error.<br/>                                                                                                       |
| 27.  | Data Types                                                                                 | ![](readmeimages/f.png)<br/>Integer literals in Rust can use an _ as a visual separator (similar to how we might write "1,000" in English, we can write "1_000" in Rust.<br/>Handling Integer Overflows - <br/>1. Depeneds whether the build is release of debug.<br/>2. In debug builds Rust runtime env checks it and program crashes whereas in release builds the behavior is left up to the programmer where they can handle it with functions provided bu the standard Rust libs or leave it.                                                                             |
| 28.  | static variables                                                                           | Can be mutable but we need unsafe code for that.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| 29.  | Type Inference                                                                             | Although Rust is a statically typed language, which means that the size of a variable should be known at compile time, the following code works - <br/>`let t = true;`<br/>That's because Rust also uses type inference, i.e. if a type is not specified explicitly Rust will use the value being assigned to the variable to **infer** the type of the variable, hence in this case **t** is **inferred as bool** and it cannot be assigned any other type of value.                                                                                                           |
| 30.  | Declaring variables                                                                        | let t = true;<br/>let f: **bool** = false;<br/>let c = 'z';<br/>let z: **char** = 'ℤ';                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 31.  | &str and String                                                                            | String - vector of characters. Default when reading input (from user or file).<br/>&str - called **string slice**.<br/>Its pointer to the string's data and a length for string as well.<br/>Used for all string literals.                                                                                                                                                                                                                                                                                                                                                      |
| 32.  | Compound types                                                                             | **Tuple** - <br/>let tup: (i32, f64, u8) = (9000, 1.1, 2);<br/>**Assignment** of tuples - <br/>let (x, y, z) = tup;<br/>**Individual elements** are accessed using index starting with 0.<br/>let a = tup.0;<br/>let b = tup.1;<br/>let c = tup.2;<br/>Empty Tuple is also called unit - (). Represents an **empty value or return type**.<br/><br/><br/>**Structs**<br/>struct User {<br/>    name: String,<br/>    age: u32,<br/>}<br/>Notice - <br/>1. We don't end a struct declaration with semi colon as in C.<br/>2. We don't use the let keyword to declare a variable. |
| 33.  | Arrays and Vectors                                                                         | Array is stored on stack, vectors on heap. Contents of array can be stroed on heap by use of pointers<br/>Arrays are fixed size, vectors can have variable size.<br/>Array access is runtime checked, access out of bounds will cause panic.                                                                                                                                                                                                                                                                                                                                    |
| 34.  | Types                                                                                      | **zero-sized type** - <br/>A zero-sized type (ZST) is a type that occupies no memory at runtime, but still exists at compile time. Essentially, it's a type that has no data fields, making it very memory efficient.<br/>Eg: unit type: ()<br/><br/>**&str** - a string slice<br/>Its an immutable reference to statically allocated string data, not owned heap storage.<br/>                                                                                                                                                                                                 |
| 34.  | Functions                                                                                  | Sample function with no return type - <br/>fn another_function(x: i32, y: i32) {<br/>    println!("The point is at: {x}, {y}");<br/>}<br/>Functions can be called before they are defined.<br/>fn func_name() -> () {<br/>// here -> () represents return type }                                                                                                                                                                                                                                                                                                                |
| 35.  | Control Flow                                                                               |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |

##### rustc - rust cool or rust compiler :)

Rust compiler enumerates every single error it throws and you can find more details about those using the compiler itself.
Following is a snapshot of error mismatched types and the second last line tells you how you can find more details about it.

![](./readmeimages/b.png)

And following is what that explanation looks like - 

![](readmeimages/a.png)

Random

Mutability

    `let var;
    var =  10;`

    This is an assignment, therefore the compiler allows the variable to be modified, but
    only one time.

Scope

    use std::io; io::stdin()

    std::io::stdon()

    Both of the above ways are identical in Rust, they have no difference when it comes
    to binary size or any other build aspect.
    Unlike in C++, where using a namespace brings all its symbols into scope which
    essentially increases the binary size regardless if all the symbols are being used or
    not.
